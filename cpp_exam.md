# Билет 1. Исключения и ошибки в C++

## Исключения в программировании

**Исключение** — это ситуация, при которой во время выполнения программы происходит ошибка или необычное событие, нарушающее нормальный ход выполнения кода.

**Исключение (exception)** — это механизм языка C++, предназначенный для обработки ошибочных или нештатных ситуаций, при которых нормальное выполнение функции невозможно или не имеет смысла.

Функция не возвращает ошибку, а **прерывает обычный поток выполнения**, передавая управление обработчику ошибки.

### Без исключений
```cpp
if (!f1()) return false;
if (!f2()) return false;
if (!f3()) return false;
```

### С исключениями
```cpp
f1();
f2();
f3();
```

---

## Ключевые слова

- **throw** — выбрасывает исключение  
  (`throw;` — проброс текущего исключения)
- **try** — оборачивает код, в котором может возникнуть исключение
- **catch** — ловит и обрабатывает исключение

---

## Что происходит при throw

1. Обычное выполнение функции прекращается  
2. Начинается поиск подходящего `catch` (первого подходящего)
3. Выполняется **stack unwinding** (раскрутка стека вызовов)
4. Вызываются деструкторы всех объектов, созданных после входа в `try`
5. Управление передаётся в `catch`
6. Если обработчик не найден — вызывается `std::terminate()`

---

## Стек вызовов

**Стек вызовов** — это структура данных (стек), в которой программа хранит информацию о текущих и вложенных вызовах функций во время выполнения.

Когда вызывается функция, в стек добавляется **кадр стека (stack frame)**.

Кадр содержит:
- адрес возврата (куда вернуться после выполнения функции),
- параметры функции,
- локальные переменные.

Когда функция завершает работу, её кадр снимается со стека, и управление возвращается вызывающей функции.

### Свойства стека
- работает только целыми кадрами (LIFO),
- не умеет «отматывать» локальные переменные выборочно,
- либо кадр снят, либо остаётся.

Следствия:
- кадры ниже обработчика уничтожаются,
- кадр с обработчиком сохраняется целиком.

---

## Error Codes

**Error code** — это способ сигнализировать об ошибках с помощью возвращаемых значений функций.

Особенности:
- нет аварий,
- нет скрытого управления,
- нет stack unwinding.

### Базовые формы
1. Через возвращаемое значение (числа в `return`)
2. Через `bool`
3. Через `enum`, `enum class`

### Плюсы
- простая и предсказуемая модель,
- дешёвые по производительности,
- подходят для низкоуровневого и realtime-кода.

### Минусы
- легко забыть проверить код ошибки,
- загромождают код проверками,
- сложно прокидывать через много уровней вызовов,
- освобождение ресурсов вручную.

---

## Исключения (Exceptions)

### Плюсы
- чистый основной код,
- автоматическая раскрутка стека и освобождение ресурсов,
- удобно обрабатывать ошибки на нужном уровне.

### Минусы
- нелинейное управление потоком,
- `throw` дорог по времени,
- сложнее отлаживать,
- не всегда допустимы (kernel, realtime).

---

## Как поймать исключения (`catch`)

- конкретный тип:  
  `catch (const T&)`
- все стандартные исключения:  
  `catch (const std::exception&)`
- абсолютно все исключения:  
  `catch (...)`

**Порядок важен:** от узкого к широкому, `catch(...)` — последним.

---

## Копирование исключений в `catch` и `throw`

- `throw expr` — создаёт объект исключения (copy или move)
- `catch (const T&)` — без копирования
- `catch (T)` — копия + slicing (преобразование к типу T, т.е. потеря своего первоначального типа)
- `throw;` — проброс без создания нового объекта

---

## Иерархия наследования исключений

Базовый класс:
- `std::exception`

Основные ветки:
- Системные исключения (`std::bad_cast`, `std::bad_alloc` и т.д.)
- `std::logic_error`
- `std::runtime_error`

### Собственное исключение
```cpp
struct MyError : std::runtime_error {
    using std::runtime_error::runtime_error;
};
```

### Интерфейс `std::exception`
```cpp
class exception {
public:
    virtual const char* what() const noexcept;
    virtual ~exception() noexcept;
};
```
Можно также наследоваться от `std::exception`, но придется переопределять метод `what()`.

---

## Ключевое слово `noexcept`

`noexcept` — это спецификатор C++, который гарантирует, что функция не выбрасывает исключения, и даёт компилятору право жёстко оптимизировать код.

### Формы

Безусловный:
```cpp
void f() noexcept;
```

Условный:
```cpp
template<typename T>
void g(T& x) noexcept(noexcept(x.swap(x)));
```

Функция является `noexcept` только если выражение внутри — `noexcept`.

При нарушении `noexcept` **немедленно вызывается `std::terminate()`**, даже если исключение возникло во вложенной функции.

---

## Исключение в конструкторе / деструкторе

- если в конструкторе выбрасывается исключение:
  - объект считается **несозданным**,
  - его деструктор **не вызывается**,
  - уже созданные поля и базовые классы корректно уничтожаются (RAII).

- деструкторы **не должны выбрасывать исключения**.

Если при раскрутке стека из-за `throw` один из деструкторов выбросит исключение — программа **немедленно завершается** через `std::terminate()`.

---
