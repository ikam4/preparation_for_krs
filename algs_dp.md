## Рюкзаки:

### Обычный рюкзак
Реализация за O(n*W)

Задача: дано ограничение по весу _W_, потом даны _n_ предметов, их веса в массиве _w_, а деньги за них в массиве _v_, надо найти макс кол-во денег.

Реализуем двумерно (O(n*W) по памяти) с восстановлением ответа:

```cpp
vector dp(n + 1, vector<int>(W + 1, 0));
for (int i = 1; i <= n; ++i) {
    for (int cap = 0; cap <= W; ++cap) {
        // Не берем i-й предмет
        dp[i][cap] = dp[i - 1][cap];
        // Берем i-й предмет (если помещается)
        if (cap >= w[i - 1]) {
            dp[i][cap] = max(dp[i][cap], dp[i - 1][cap - w[i - 1]] + v[i - 1]);
        }
    }
}
// Восстановление набора предметов
vector<int> picked;
int cap = W;
for (int i = n; i >= 1; --i) {
    // Проверяем, мог ли i-й предмет быть взят 
    if (cap >= w[i - 1] && dp[i][cap] == dp[i - 1][cap - w[i - 1]] + v[i - 1]) {
        picked.push_back(i);   // сохраняем 1-индексацию
        cap -= w[i - 1];       // уменьшаем оставшуюся вместимость
    }
    // иначе i-й не брали, просто идем дальше
}
reverse(picked.begin(), picked.end());
cout << dp[n][W] << "\n";
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```

Ниже реализация, оптимизированная до O(w) по памяти с восстановлением ответа:

```cpp
vector<int> dp(W + 1, 0);
vector<int> parent(W + 1, -1); // какой предмет последним положил оптимум в dp[cap]
for (int i = 0; i < n; ++i) {
    for (int cap = W; cap >= w[i]; --cap) {  // идём назад! — чтобы предмет i использовался 1 раз
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;
            parent[cap] = i;
        }
    }
}
cout << dp[W] << "\n";
// восстановление ответа
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];
    picked.push_back(p + 1); // переводим в 1-индексацию
    cap -= w[p];             // возвращаемся на предыдущий вес
}
for (int i = 0; i < (int)picked.size(); ++i)
    cout << picked[i] << ' ';
```
---
### Ограниченный рюкзак 
Любой предмет может быть взят некоторое количество раз (дано в условии)

Задача: дано n предметов с весами _w_i_, ценностями _v_i_ и ограничениями по количеству _c_i_, при вместимости рюкзака _W_ требуется максимизировать суммарную ценность, выбирая не более _c_i_ экземпляров каждого предмета так, чтобы суммарный вес не превышал _W_.

Сначала реализуем наивно за O(n*W\*W), но с оптимизацией по памяти, используя только два слоя
```cpp
vector<int> dp(W + 1, 0); // dp[cap] — максимальная ценность для вместимости cap

// Обрабатываем каждый предмет
for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // сохраняем состояние dp до использования предмета i

    // Пробегаем по всем возможным вместимостям
    for (int cap = 0; cap <= W; ++cap) {
        int best = prev[cap]; // k = 0, не берем предмет i

        // Пробуем взять k штук предмета i, где k не превышает ограничения c[i]
        // и вместимость cap позволяет взять k штук
        for (int k = 1; k <= min(c[i], cap / w[i]); ++k) {
            best = max(best, prev[cap - k * w[i]] + k * v[i]); // выбираем максимум
        }

        dp[cap] = best; // обновляем dp для текущей вместимости
    }
}

// Выводим максимальную ценность для вместимости W
cout << dp[W] << "\n";
```

Можно оптимизировать до O(n*w\*logw). Количество каждого предмета разложим по степеням двойки (степени двойки будем записывать СТРОГО последовательно, не как в двоичной записи числа, из-за чего в конце может быть остаток, но это не проблема) и добавим новые предметы количеством 1, и весом, равным весу предмета, умноженного на полученную в разложении степень двойки (или остаток). Затем решим как задачку обычного рюкзака.

Если требуется максимизация веса, а не стоимости, можно оптимизировать до O(n*W), используя монотонную очередь
(то есть решение неверно для приведенной выше задачи, но если надо было бы найти макс вес, то все бы работало).
```cpp
vector<int> dp(W + 1, 0); // dp[r] — максимальный вес для вместимости r (если максимизируем вес)

for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // сохраняем состояние до обработки предмета i

    // Разбиваем все вместимости по остаткам от деления на w[i]
    // Это позволяет обрабатывать все cap вида r + m*w[i], m = 0..M
    for (int r = 0; r < w[i]; ++r) {
        deque<pair<int,int>> dq; // хранит пары (m', value), максимум в окне спереди
        int M = (W - r) / w[i];  // максимальное количество предметов данного типа для остатка r

        for (int m = 0; m <= M; ++m) {
            int idx = r + m * w[i];       // текущая вместимость
            int val = prev[idx] - m * v[i]; // значение для текущего количества m (если максимизируем вес, v[i] = w[i])

            // Поддерживаем убывающий порядок value в деке
            while (!dq.empty() && dq.back().second <= val) dq.pop_back();
            dq.emplace_back(m, val); // вставляем текущий m

            // Удаляем устаревшие элементы из передней части дека
            // чтобы не превышать ограничение по количеству c[i]
            while (!dq.empty() && dq.front().first < m - c[i]) dq.pop_front();

            // Максимум в текущем окне — спереди
            dp[idx] = dq.front().second + m * v[i]; // обновляем dp
        }
    }
}

cout << dp[W] << "\n"; // максимальный вес для вместимости W
```
---
###  Неограниченный рюкзак
Любой предмет может быть выбран любое количество раз

От обычного рюкзака отличается только тем, что во внутреннем цикле мы бежим не от обратного, чтобы каждый элемент можно было использовать сколь угодно раз
```cpp
vector<int> dp(W + 1, 0);       // dp[cap] — максимальная ценность для вместимости cap
vector<int> parent(W + 1, -1);  // parent[cap] — какой предмет последним положил оптимум

// Основной DP для неограниченного рюкзака
for (int i = 0; i < n; ++i) {
    for (int cap = w[i]; cap <= W; ++cap) {
        // Рассматриваем возможность добавить текущий предмет i
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;       // обновляем максимум
            parent[cap] = i;      // сохраняем индекс предмета, который дал этот максимум
        }
    }
}

// Вывод максимальной ценности
cout << dp[W] << "\n";

// Восстановление выбранных предметов
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];           // предмет, который последним положили
    picked.push_back(p + 1);       // переводим в 1-индексацию для удобного вывода
    cap -= w[p];                   // уменьшаем вместимость на вес выбранного предмета
}

// Вывод выбранных предметов
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```
---
### (ДОП) Реализация очереди с поддержкой максимума (минимума)

**Идея реализации**

1. **Два стека**  
   - `inStack` — обычный стек для добавления элементов (`push`).  
   - `outStack` — стек пар `(значение, локальный max, локальный min)` для удаления элементов (`pop`) с хранением локального максимума и минимума.  

2. **Добавление элемента (`push`)**  
   - Кладём значение в `inStack`.  
   - Локальный max/min не нужен на этом этапе, поэтому пары не создаём.  

3. **Удаление элемента (`pop`)**  
   - Если `outStack` пуст, переносим все элементы из `inStack` в `outStack`.  
   - При переносе для каждого элемента пересчитываем локальный max/min относительно уже заполненного `outStack`:  
     ```
     локальный max = max(значение, верхний локальный max outStack)
     локальный min = min(значение, верхний локальный min outStack)
     ```
   - После этого удаляем верхний элемент `outStack`.  

4. **Получение фронт-элемента (`front`)**  
   - Если `outStack` пуст, сначала делаем перенос.  
   - Верх `outStack` — это первый элемент очереди.  

5. **Получение максимума/минимума всей очереди (`getMax` / `getMin`)**  
   - Берём максимум и минимум из двух источников:  
     - `outStack.top().curMax` и `outStack.top().curMin` (элементы готовые к удалению).  
     - `inStack` — если нужно, можно пройти по нему, чтобы найти max/min среди ещё не перенесённых элементов.  
   - Амортизированно операции остаются **O(1)**, так как пересчёт по `inStack` выполняется только при переносе.

**Объяснение от Максима Г.:**

Будем хранить два стека - In(std::stack<T>), Out(std::stack<pair<T, T>>) и переменную M в которой будем хранить max/min в In.
Добавлять элементы будем In, тогда M = max/min(M, value). Когда необходимо будет удалить элемент, возможны два варианта: 
1) Out.size() == 0: тогда переносим все элементы из In в Out начиная с конца следующим образом: .first = value, .second = max/min на префиксе. Тогда первый элемент из In будет последним в Out и его смело можно удалять и max/min нашей структуры будет равен Out.top().second.
2) Out.size() != 0: тогда мы удаляем последний элемент из Out(то есть самый первый в нашей "очереди"), но ответ будет уже равен max/min(Out.top().second, M)

---
---
## Последовательности:

### НВП (наибольшая возрастающая подпоследовательность)

Задача: в массиве _arr_ записаны числа, найти их НВП.

Реализуем решение наивно за O(n*n):
```cpp
int n = arr.size();
vector<int> dp(n, 1);       // dp[i] длина НВП, оканчивающейся в i
vector<int> prev(n, -1);    // prev[i] — предыдущий индекс в НВП для восстановления
// Основной DP
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
            dp[i] = dp[j] + 1;
            prev[i] = j;
        }
    }
}
// Находим индекс конца НВП
auto it = max_element(dp.begin(), dp.end());
int lis_len = *it;
int index = it - dp.begin();
// Восстанавливаем НВП
vector<int> lis_sequence;
while (index != -1) {
    lis_sequence.push_back(arr[index]);
    index = prev[index];
}
reverse(lis_sequence.begin(), lis_sequence.end());
cout << lis_sequence.size() << '\n';
for (auto i: lis_sequence)
    cout << i << ' ';
```



