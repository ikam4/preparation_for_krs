## Рюкзаки:

### Обычный рюкзак
Реализация за O(n*W) по времени

Задача: дано ограничение по весу `W`, потом даны `n` предметов, их веса в массиве `w`, а деньги за них в массиве `v`, надо найти макс кол-во денег.

Реализуем двумерно (O(n*W) по памяти) с восстановлением ответа:

```cpp
vector dp(n + 1, vector<int>(W + 1, 0));
for (int i = 1; i <= n; ++i) {
    for (int cap = 0; cap <= W; ++cap) {
        // Не берем i-й предмет
        dp[i][cap] = dp[i - 1][cap];
        // Берем i-й предмет (если помещается)
        if (cap >= w[i - 1]) {
            dp[i][cap] = max(dp[i][cap], dp[i - 1][cap - w[i - 1]] + v[i - 1]);
        }
    }
}
// Восстановление набора предметов
vector<int> picked;
int cap = W;
for (int i = n; i >= 1; --i) {
    // Проверяем, мог ли i-й предмет быть взят 
    if (cap >= w[i - 1] && dp[i][cap] == dp[i - 1][cap - w[i - 1]] + v[i - 1]) {
        picked.push_back(i);   // сохраняем 1-индексацию
        cap -= w[i - 1];       // уменьшаем оставшуюся вместимость
    }
    // иначе i-й не брали, просто идем дальше
}
reverse(picked.begin(), picked.end());
cout << dp[n][W] << "\n";
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```

Ниже реализация, оптимизированная до O(W) по памяти с восстановлением ответа:

```cpp
vector<int> dp(W + 1, 0);
vector<int> parent(W + 1, -1); // какой предмет последним положил оптимум в dp[cap]
for (int i = 0; i < n; ++i) {
    for (int cap = W; cap >= w[i]; --cap) {  // идём назад! — чтобы предмет i использовался 1 раз
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;
            parent[cap] = i;
        }
    }
}
cout << dp[W] << "\n";
// восстановление ответа
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];
    picked.push_back(p + 1); // переводим в 1-индексацию
    cap -= w[p];             // возвращаемся на предыдущий вес
}
for (int i = 0; i < (int)picked.size(); ++i)
    cout << picked[i] << ' ';
```
---
### Ограниченный рюкзак 
Любой предмет может быть взят некоторое количество раз (дано в условии)

Задача: дано n предметов с весами `w_i`, ценностями `v_i` и ограничениями по количеству `c_i`, при вместимости рюкзака `W` требуется максимизировать суммарную ценность, выбирая не более `c_i` экземпляров каждого предмета так, чтобы суммарный вес не превышал `W`.

Сначала реализуем наивно за O(n*W\*W) по времени, но с оптимизацией по памяти до O(W), используя только два слоя:
```cpp
vector<int> dp(W + 1, 0); // dp[cap] — максимальная ценность для вместимости cap

// Обрабатываем каждый предмет
for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // сохраняем состояние dp до использования предмета i

    // Пробегаем по всем возможным вместимостям
    for (int cap = 0; cap <= W; ++cap) {
        int best = prev[cap]; // k = 0, не берем предмет i

        // Пробуем взять k штук предмета i, где k не превышает ограничения c[i]
        // и вместимость cap позволяет взять k штук
        for (int k = 1; k <= min(c[i], cap / w[i]); ++k) {
            best = max(best, prev[cap - k * w[i]] + k * v[i]); // выбираем максимум
        }

        dp[cap] = best; // обновляем dp для текущей вместимости
    }
}

// Выводим максимальную ценность для вместимости W
cout << dp[W] << "\n";
```

Можно оптимизировать до O(n*W\*logW) по времени. Количество каждого предмета разложим по степеням двойки (степени двойки будем записывать СТРОГО последовательно, не как в двоичной записи числа, из-за чего в конце может быть остаток, но это не проблема) и добавим новые предметы количеством 1, и весом, равным весу предмета, умноженного на полученную в разложении степень двойки (или остаток). Затем решим как задачку обычного рюкзака.

Можно оптимизировать до O(n*W) по времени, используя монотонную очередь (будем искать макс. вес).
```cpp
vector<int> dp(W + 1, 0); // dp[r] — максимальный вес для вместимости r (если максимизируем вес)

for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // сохраняем состояние до обработки предмета i

    // Разбиваем все вместимости по остаткам от деления на w[i]
    // Это позволяет обрабатывать все cap вида r + m*w[i], m = 0..M
    for (int r = 0; r < w[i]; ++r) {
        deque<pair<int,int>> dq; // хранит пары (m', value), максимум в окне спереди
        int M = (W - r) / w[i];  // максимальное количество предметов данного типа для остатка r

        for (int m = 0; m <= M; ++m) {
            int idx = r + m * w[i];       // текущая вместимость
            int val = prev[idx] - m * v[i]; // значение для текущего количества m (если максимизируем вес, v[i] = w[i])

            // Поддерживаем убывающий порядок value в деке
            while (!dq.empty() && dq.back().second <= val) dq.pop_back();
            dq.emplace_back(m, val); // вставляем текущий m

            // Удаляем устаревшие элементы из передней части дека
            // чтобы не превышать ограничение по количеству c[i]
            while (!dq.empty() && dq.front().first < m - c[i]) dq.pop_front();

            // Максимум в текущем окне — спереди
            dp[idx] = dq.front().second + m * v[i]; // обновляем dp
        }
    }
}

cout << dp[W] << "\n"; // максимальный вес для вместимости W
```
---
###  Неограниченный рюкзак
Любой предмет может быть выбран любое количество раз

От обычного рюкзака отличается только тем, что во внутреннем цикле мы бежим не от обратного, чтобы каждый элемент можно было использовать сколь угодно раз
```cpp
vector<int> dp(W + 1, 0);       // dp[cap] — максимальная ценность для вместимости cap
vector<int> parent(W + 1, -1);  // parent[cap] — какой предмет последним положил оптимум

// Основной DP для неограниченного рюкзака
for (int i = 0; i < n; ++i) {
    for (int cap = w[i]; cap <= W; ++cap) {
        // Рассматриваем возможность добавить текущий предмет i
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;       // обновляем максимум
            parent[cap] = i;      // сохраняем индекс предмета, который дал этот максимум
        }
    }
}

// Вывод максимальной ценности
cout << dp[W] << "\n";

// Восстановление выбранных предметов
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];           // предмет, который последним положили
    picked.push_back(p + 1);       // переводим в 1-индексацию для удобного вывода
    cap -= w[p];                   // уменьшаем вместимость на вес выбранного предмета
}

// Вывод выбранных предметов
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```
---
### (ДОП) Реализация очереди с поддержкой максимума (минимума)

**Идея реализации**

1. **Два стека**  
   - `inStack` — обычный стек для добавления элементов (`push`).  
   - `outStack` — стек пар `(значение, локальный max, локальный min)` для удаления элементов (`pop`) с хранением локального максимума и минимума.  

2. **Добавление элемента (`push`)**  
   - Кладём значение в `inStack`.  
   - Локальный max/min не нужен на этом этапе, поэтому пары не создаём.  

3. **Удаление элемента (`pop`)**  
   - Если `outStack` пуст, переносим все элементы из `inStack` в `outStack`.  
   - При переносе для каждого элемента пересчитываем локальный max/min относительно уже заполненного `outStack`:  
     ```
     локальный max = max(значение, верхний локальный max outStack)
     локальный min = min(значение, верхний локальный min outStack)
     ```
   - После этого удаляем верхний элемент `outStack`.  

4. **Получение фронт-элемента (`front`)**  
   - Если `outStack` пуст, сначала делаем перенос.  
   - Верх `outStack` — это первый элемент очереди.  

5. **Получение максимума/минимума всей очереди (`getMax` / `getMin`)**  
   - Берём максимум и минимум из двух источников:  
     - `outStack.top().curMax` и `outStack.top().curMin` (элементы готовые к удалению).  
     - `inStack` — если нужно, можно пройти по нему, чтобы найти max/min среди ещё не перенесённых элементов.  
   - Амортизированно операции остаются **O(1)**, так как пересчёт по `inStack` выполняется только при переносе.

**Объяснение от Максима Г.:**

Будем хранить два стека - In(std::stack<T>), Out(std::stack<pair<T, T>>) и переменную M в которой будем хранить max/min в In.
Добавлять элементы будем In, тогда M = max/min(M, value). Когда необходимо будет удалить элемент, возможны два варианта: 
1) Out.size() == 0: тогда переносим все элементы из In в Out начиная с конца следующим образом: .first = value, .second = max/min на префиксе. Тогда первый элемент из In будет последним в Out и его смело можно удалять и max/min нашей структуры будет равен Out.top().second.
2) Out.size() != 0: тогда мы удаляем последний элемент из Out(то есть самый первый в нашей "очереди"), но ответ будет уже равен max/min(Out.top().second, M)

---
---
## Последовательности:

### НВП (наибольшая возрастающая подпоследовательность)

Задача: в массиве `arr` записаны числа, найти их НВП.

Реализуем решение наивно за O(n*n) по времени и за O(n) по памяти:
```cpp
int n = arr.size();
vector<int> dp(n, 1);       // dp[i] — длина НВП, оканчивающейся в i
vector<int> prev(n, -1);    // prev[i] — предыдущий индекс в НВП для восстановления

// Основной DP: для каждого элемента i проверяем элементы j < i
// и продолжаем возрастающую подпоследовательность
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
            dp[i] = dp[j] + 1; // увеличиваем длину НВП
            prev[i] = j;       // сохраняем предыдущий элемент
        }
    }
}

// Находим индекс конца НВП
auto it = max_element(dp.begin(), dp.end());
int lis_len = *it;           // длина НВП
int index = it - dp.begin(); // индекс конца НВП

// Восстанавливаем НВП
vector<int> lis;
while (index != -1) {
    lis.push_back(arr[index]); // добавляем элемент
    index = prev[index];       // идём к предыдущему элементу
}
reverse(lis.begin(), lis.end()); // переворачиваем для правильного порядка

// Вывод результатов
cout << lis.size() << '\n'; // длина НВП
for (auto i : lis)           // сами элементы НВП
    cout << i << ' ';
```

Оптимизируем решение до O(n*logn) по времени, немного изменив логику dp:

```cpp
int n = a.size();

vector<int> dp(n + 1, INT_MAX);       // dp[i] — минимальный конец возрастающей подпоследовательности длины i
vector<int> pos(n + 1, -1);  // pos[i] — индекс элемента, который завершает подпоследовательность длины i
vector<int> prev(n, -1);     // prev[i] — предыдущий индекс элемента для восстановления НВП
dp[0] = INT_MIN;             // для длины 0
int length = 0;

for (int i = 0; i < n; i++) {
    // бинарный поиск: найти j, чтобы dp[j-1] < a[i] <= dp[j]
    int j = lower_bound(dp.begin(), dp.begin() + n + 1, a[i]) - dp.begin();
    if (a[i] != dp[j]) { //чтобы не восстановилось два одинаковых элемента
        dp[j] = a[i];
        pos[j] = i;               // запоминаем индекс элемента
        prev[i] = pos[j - 1];     // предыдущий элемент НВП
        length = max(length, j);  // обновляем длину НВП
    }
}

// Восстановление НВП
vector<int> lis;
int p = pos[length];
while (p != -1) {
    lis.push_back(a[p]);
    p = prev[p];
}
reverse(lis.begin(), lis.end());

// Вывод результатов
cout << lis.size() << '\n';
for (int x : lis)
    cout << x << ' ';
```
---
### НОП (наибольшая общая подпоследовательность)

Задача: в массивах `a` и `b` записаны числа, найти их НОП.

Реализуем решение за O(n*m) по времени и памяти:
```cpp
int n = a.size();
int m = b.size();

// dp[i][j] — длина НОП для a[0..i-1] и b[0..j-1]
vector dp(n + 1, vector<int>(m + 1, 0));

// Заполняем DP
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (a[i - 1] == b[j - 1])
            dp[i][j] = dp[i - 1][j - 1] + 1;
        else
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
    }
}

// Восстановление
int i = n, j = m;
vector<int> res;

while (i > 0 && j > 0) {
    if (a[i - 1] == b[j - 1]) {
        res.push_back(a[i - 1]);
        i--;
        j--;
    } else {
        if (dp[i - 1][j] >= dp[i][j - 1])
            i--;
        else
            j--;
    }
}

reverse(res.begin(), res.end());
```

---
### НОВП (наибольшая общая возрастающая последовательность)

Задача: в массивах `a` и `b` записаны числа, найти их НОВП.

Наивное решение за O(n\*n\*m\*m) по времени: dp[i][j] - максимальная длина НОВП, заканчивающейся в позициях i и j, переход за O(n*m) через прямой перебор предыдущих значений i и j

Более оптимизированное O(n\*m\*m) по времени: dp[i][j] - максимальная длина НОВП, заканчивающейся в позиции j второй строки, переход либо к dp[i - 1][j], либо к 1 + dp[i - 1][j'] за O(m) через прямой перебор j'

Оптимизируем до O(n*m) по времени, используя доп. переменную best:
dp как в прошлом решении. Основная сложность прошлого решения - поиск j' = arg max(dp[i - 1][j']) при b[j'] < b[j] и j' < j. Значение j' вычисляется только при b[j] = a[i]. Считаем динамику первым циклом по возрастанию i, значит a[i] фиксировано, а значит и b[j] фиксировано. И значение j' можно поддерживать на префиксе за O(1) при переходе от j к j + 1

Реализация за O(n*m) по времени и памяти:
```cpp
// dp[i][j]  — длина НОВП для префиксов a[0..i-1], b[0..j-1],
//               заканчивающаяся на элементе b[j-1], если a[i-1] == b[j-1].
// prev[j]   — позиция предыдущего элемента НОВП в массиве b (для восстановления).

vector dp(n + 1, vector<int>(m + 1, 0));
vector<int> prev(m + 1, 0);

for (int i = 1; i <= n; ++i) {
    int best = 0;     // лучшая длина НОВП среди b[0..j-1], но только тех b[k] < a[i-1]
    int idx = 0;      // позиция b[k], которая даёт best
    for (int j = 1; j <= m; ++j) {
        // По умолчанию: НОВП не улучшается по сравнению с dp[i-1][j]
        dp[i][j] = dp[i - 1][j];
        // Если найден общий элемент, и можно улучшить НОВП, заканчивающуюся на b[j-1]
        if (a[i - 1] == b[j - 1] && dp[i - 1][j] < best + 1) {
            dp[i][j] = best + 1;
            prev[j] = idx;   // сохраним, откуда мы пришли
        }
        // Если b[j-1] < a[i-1], то этот b[j-1] можно использовать
        // как возможный предыдущий элемент НОВП.
        // И если dp[i-1][j] лучше нынешнего "best" → обновляем best.
        if (a[i - 1] > b[j - 1] && best < dp[i - 1][j]) {
            best = dp[i - 1][j];
            idx = j;
        }
    }
}

// Теперь находим, где НОВП заканчивается
int pos = 0;
for (int j = 1; j <= m; ++j) {
    if (dp[n][j] > dp[n][pos]) {
        pos = j;
    }
}

// Восстановление ответа
vector<int> ans;
while (pos != 0) {
    ans.push_back(b[pos - 1]);  // берем элемент
    pos = prev[pos];            // двигаемся по цепочке
}

// Ответ восстановлен в обратном порядке
reverse(ans.begin(), ans.end());
// Вывод
cout << ans.size() << "\n";
for (int x : ans) cout << x << " ";
```
---
---
## ДП на подмножествах

### Перебор всех подмножеств подмножеств

Сначала докажем, что количество всех подмножеств подмножеств равно `3^n`

Рассмотрим каждый элемент x ∈ S.  
В паре (A, B) с A ⊆ B ⊆ S элемент x может находиться ровно в одном из трёх состояний:

1. x ∉ B → тогда x ∉ A;  
2. x ∈ B, но x ∉ A;  
3. x ∈ A → тогда x ∈ B.

Эти три случая исчерпывают все возможности и взаимно исключают друг друга.

Поскольку выбор состояния для каждого из n элементов независим, общее число пар равно:

3 × 3 × ... × 3 (n раз) = 3^n

```cpp
for (int mask = 0; mask < (1 << n); ++mask) {
    for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {
        // обработка submask
    }
    // если mask != 0, то submask == 0 не обработан — добавим отдельно
    // обработка пустого подмножества (submask == 0)
}
```

---
### Задача о сумме подмножеств элементов

Условие: сколько подмножеств элементов в множестве `a` размером `n` имеют сумму не меньше X.

Решение за O(2^n) по времени и памяти (сразу оптимизированное, есть и наивное за O(2^n*n) по времени, когда мы пересчитываем каждый раз сумму):
```cpp
int total_masks = 1 << n;              // всего подмножеств
vector<long long> dp(total_masks);     // dp[mask] = сумма элементов в подмножестве mask

dp[0] = 0;                             // пустое подмножество

for (int mask = 1; mask < total_masks; ++mask) {
    // lsb — младший установленный бит в mask
    int lsb = mask & -mask;           // бит, соответствующий одному элементу
    // индекс этого бита: количество нулей в конце
    int i = __builtin_ctz(lsb);       // позиция элемента, который добавили
    int prev = mask ^ lsb;           // маска без этого элемента
    dp[mask] = dp[prev] + a[i];      // сумма = сумма без элемента + значение элемента
}

long long answer = 0;
for (int mask = 0; mask < total_masks; ++mask) {
    if (dp[mask] >= X) {
        ++answer;
    }
}

// если НЕ хотим считать пустое подмножество
// if (dp[0] >= X) --answer;

cout << answer << "\n";
```

#### Примечание: 

- -mask = 1 + ~mask (так хранятся в памяти компьютера отрицательные числа)
- mask:     ...xxxxx1000  (x - любые биты)
- ~mask:    ...yyyyy0111  (y - инвертированные x)
- -mask:    ...yyyyy1000  (+1 вызывает перенос до первой единицы)
Поэтому mask & -mask возвращает первый справа единичный бит.
Можно брать и первый слева единичный бит следующим образом (если берём у int, который 32 бита): `int i = 31 - __builtin_ctz(lsb); `
---

### Задача о распределении задач

Условие: Есть `n` человек и `n` задач, а также полезность `cost[i][j]`, которую можно получить, если дать человеку `i` задачу `j` и получить `cost[i][j]`. Как распределить людей по задачам, чтобы получить максимальную суммарную полезность?

Решение за O(n*2^n) по времени и O(2^n) по памяти:
```cpp
int total_masks = 1 << n;
const long long NEG_INF = (long long)-4e18;

vector<long long> dp(total_masks, NEG_INF);
dp[0] = 0; // никого не назначили

for (int mask = 0; mask < total_masks; ++mask) {
    int k = __builtin_popcount(mask);  // сколько задач занято -> номер человека
    if (k >= n) continue;             // на всякий случай

    // пытаемся назначить человеку k любую ещё свободную задачу j
    for (int j = 0; j < n; ++j) {
        if (!(mask & (1 << j))) {     // задача j ещё свободна
            int new_mask = mask | (1 << j);
            dp[new_mask] = max(dp[new_mask], dp[mask] + cost[k][j]);
        }
    }
}

cout << dp[total_masks - 1] << "\n";  // максимальная суммарная полезность
```

---
### Задача коммивояжера

- `n` городов и матрица расстояний `dist[i][j]` между ними.
- Требуется найти **замкнутый маршрут минимальной длины**, который:
  - Начинается и заканчивается в одном и том же городе.
  - Посещает каждый город **ровно один раз**.

#### Основные понятия

1. Маска посещенных городов представляется как целое число, где каждый бит соответствует городу: `1` — город посещён, `0` — город ещё не посещён.
2. `dp[mask][v]` — минимальная стоимость пути, который проходит через все города из `mask` и заканчивается в городе `v`.
3. В `parent[mask][v]` сохраняем предыдущий город для восстановления полного маршрута.


#### Шаги алгоритма

1. Инициализация
    - Выбираем стартовый город (например, город 0).
    - `dp[1 << 0][0] = 0` — путь, который включает только стартовый город, имеет длину 0.
    - Если между двумя городами пути нет, в матрице расстояний ставим `INF` (большое число).

2. Заполнение DP (для каждой `mask` и города `u` в маске):
    - Проверяем все города `v`, которых ещё нет в маске (`mask & (1 << v) == 0`).
    - Вычисляем новую маску: `nmask = mask | (1 << v)`.
    - Если путь через `u` к `v` улучшает текущую стоимость:
       - Обновляем `dp[nmask][v] = dp[mask][u] + dist[u][v]`.
       - Запоминаем родителя: `parent[nmask][v] = u`.
    - Таким образом, постепенно строим минимальные пути для всех возможных подмножеств городов.

3. После того как посещены все города (`mask = FULL-1`):
    - Рассматриваем все возможные последние города `u`.
    - Добавляем стоимость возврата в стартовый город: `dp[FULL-1][u] + dist[u][0]`.
    - Выбираем минимальное значение — это **минимальная длина замкнутого маршрута**.

4. Восстановление маршрута
    - Начинаем с последнего города `last`, который дал минимальную стоимость.
    - Используем массив `parent` и маску `mask`, чтобы идти **назад** по маршруту, пока не достигнем стартового города.
    - Разворачиваем полученный путь и добавляем стартовый город в конец, чтобы получить полный цикл.

#### Сложность алгоритма
- Время: `O(n^2 * 2^n)`  
- Память: `O(n * 2^n)`  

#### Пример реализации: 
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long INF = 1e18;

int main() {
    int n;
    cin >> n; // количество городов
    vector dist(n, vector<long long>(n));
    
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < n; ++j){
            cin >> dist[i][j];
            if(dist[i][j] < 0) dist[i][j] = INF; // если пути нет
        }

    int FULL = 1 << n; // все возможные подмножества городов
    vector dp(FULL, vector<long long>(n, INF));
    vector parent(FULL, vector<int>(n, -1));

    dp[1][0] = 0; // стартуем с города 0

    // перебираем все подмножества городов
    for(int mask = 1; mask < FULL; ++mask) {
        for(int u = 0; u < n; ++u) {
            if(!(mask & (1 << u))) continue; // город u не в маске
            if(dp[mask][u] == INF) continue;

            // пробуем добавить следующий город v
            for(int v = 0; v < n; ++v) {
                if(mask & (1 << v)) continue; // город уже в пути
                if(dist[u][v] == INF) continue; // пути нет
                int nmask = mask | (1 << v);
                if(dp[mask][u] + dist[u][v] < dp[nmask][v]) {
                    dp[nmask][v] = dp[mask][u] + dist[u][v];
                    parent[nmask][v] = u;
                }
            }
        }
    }

    // закрываем цикл, возвращаемся в старт
    long long best = INF;
    int last = -1;
    for(int u = 0; u < n; ++u) {
        if(dp[FULL-1][u] == INF || dist[u][0] == INF) continue;
        long long cost = dp[FULL-1][u] + dist[u][0];
        if(cost < best) {
            best = cost;
            last = u;
        }
    }

    if(best == INF) {
        cout << "NO SOLUTION\n";
        return 0;
    }

    // восстановление пути
    vector<int> path;
    int mask = FULL-1, v = last;
    while(v != -1) {
        path.push_back(v);
        int pv = parent[mask][v];
        mask ^= (1 << v);
        v = pv;
    }
    reverse(path.begin(), path.end());
    path.push_back(0); // возвращение в старт

    // вывод
    cout << best << "\n";
    for(int i = 0; i < path.size(); ++i) {
        cout << (path[i] + 1) << ' '; // 1-based номера городов
    }
}
```
---

## Принцип включений-исключений

Пусть даны конечные множества  
A₁, A₂, …, Aₙ ⊆ U.

Тогда мощность их объединения:

|A₁ ∪ A₂ ∪ … ∪ Aₙ| =  Σ|Aᵢ| − Σ|Aᵢ ∩ Aⱼ| + Σ|Aᵢ ∩ Aⱼ ∩ Aₖ| − … + (−1)ⁿ⁺¹ |A₁ ∩ A₂ ∩ … ∩ Aₙ|

Где суммы берутся по всем 1 ≤ i ≤ n,  
1 ≤ i < j ≤ n,  
1 ≤ i < j < k ≤ n и т.д.

#### Идея:

- Сначала **включаем** все элементы каждого множества (но считаем пересечения дважды).
- Потом **исключаем** пересечения пар (но теперь тройные пересечения учтены недостаточно).
- И так далее — **чередуем включение и исключение**.

#### Пример (n = 3):

|A ∪ B ∪ C| = |A| + |B| + |C| − |A∩B| − |A∩C| − |B∩C| + |A∩B∩C|

---

## Динамика по разрядам

Задача: Найти количество чисел в диапазоне [0..n], делящихся на m и состоящих только из цифр {1, 2, 3} 

Реализация за O(m*logn) по времени и памяти (L = log_10(n)):
```cpp
// Переводим n в строку, чтобы удобно работать с цифрами по позициям.
string s = to_string(n);
int L = (int)s.size();   // количество цифр у n

// -----------------------------
// Часть 1: длины строго меньше L
// -----------------------------
//
// dp1[pos][rem] — количество способов набрать число длины pos
// (ровно pos цифр), состоящее только из {1,2,3},
// так что остаток по модулю m равен rem.
//
// Здесь нет ограничения сверху (никакой связи с n),
// поэтому это обычная ДП по длине.
//
// Нам нужны только длины pos от 0 до L-1.
// pos = 0: пустое число, считаем его как 1 способ с rem = 0.

vector<vector<int>> dp1(L + 1, vector<int>(m, 0));
dp1[0][0] = 1;  // пустой префикс, остаток 0

// Строим числа длины до L (включая L, но для длины L результат
// здесь использовать не будем, это "верхнее" приближение).
for (int pos = 0; pos < L; ++pos) {
    for (int rem = 0; rem < m; ++rem) {
        int cur = dp1[pos][rem];
        if (!cur) continue; // если нет способов, пропускаем
        // На новую позицию можем поставить любую цифру из {1,2,3}.
        for (int d : {1, 2, 3}) {
            // Новый остаток с учётом добавленной цифры d.
            int new_rem = (rem * 10 + d) % m;
            dp1[pos + 1][new_rem] += cur;
        }
    }
}

// answer будет накапливать общий ответ.
int answer = 0;

// Добавляем вклад чисел длины от 1 до L-1.
// Для каждой длины len, все числа из {1,2,3} длины len гарантированно < n,
// поэтому просто берём dp1[len][0] (остаток 0).
for (int len = 1; len < L; ++len) {
    answer += dp1[len][0];
}

// ---------------------------------
// Часть 2: длина ровно L, число <= n
// ---------------------------------
//
// Теперь считаем только числа длины ровно L.
// Они могут быть как строго меньше n, так и равны n.
// Для этого введём dp2[digit][rem][equal]:
//
// digit — сколько старших цифр уже выбрано (от 0 до L).
// rem   — остаток по модулю m от уже набранного префикса.
// equal — флаг:
//         1 — если получившийся префикс численно равен первым digit цифрам n;
//         0 — если он уже строго меньше (то есть на какой-то позиции мы поставили
//              цифру меньше, чем в n).
//
// При equal=1 нельзя ставить на текущую позицию цифру > соответствующей цифры n,
// иначе мы превысим n. При equal=0 ограничений снизу/сверху нет
// (кроме того, что использовать можно только {1,2,3}).
//
// В отличие от dp1, здесь учитываем именно ограничение сверху n.

vector dp2(L + 1, vector<array<int, 2>>(m, {0, 0}));

// Инициализация:
// digit = 0: ещё не выбрали ни одной цифры, остаток rem = 0,
// equal = 1, так как пустой префикс равен пустому префиксу n.
dp2[0][0][1] = 1;

// Перебираем позиции от 0 до L-1.
for (int digit = 0; digit < L; ++digit) {
    // Текущая цифра n на позиции digit.
    // Например, если n = 326, то:
    // digit = 0 -> limit = 3,
    // digit = 1 -> limit = 2,
    // digit = 2 -> limit = 6.
    int limit = s[digit] - '0';

    for (int rem = 0; rem < m; ++rem) {
        for (int equal = 0; equal <= 1; ++equal) {
            int cur = dp2[digit][rem][equal];
            if (!cur) continue;

            if (equal == 1) {
                // Префикс пока равен префиксу n.
                // Значит, следующая цифра d не должна быть больше limit.
                for (int d : {1, 2, 3}) {
                    // Цифры больше limit использовать нельзя.
                    if (d > limit) break;

                    // Новый остаток.
                    int new_rem = (rem * 10 + d) % m;

                    // Если d == limit, то новый префикс всё ещё равен
                    // префиксу n -> new_equal = 1.
                    // Если d < limit, то новый префикс уже меньше n -> new_equal = 0.
                    int new_equal = (d == limit ? 1 : 0);

                    dp2[digit + 1][new_rem][new_equal] += cur;
                }
            } else {
                // equal == 0: префикс уже строго меньше n,
                // значит, ограничений сверху больше нет, кроме выбора цифр {1,2,3}.
                for (int d : {1, 2, 3}) {
                    int new_rem = (rem * 10 + d) % m;
                    // Раз уж префикс меньше n, он и останется меньше.
                    dp2[digit + 1][new_rem][0] += cur;
                }
            }
        }
    }
}

// После обработки всех L позиций мы получили dp2[L][rem][equal].
// Нас интересуют числа длины ровно L, делящиеся на m (rem == 0),
// и не превосходящие n. То есть подходят оба equal:
//  equal = 0 — строго меньше n,
//  equal = 1 — равно n.
answer += dp2[L][0][0] + dp2[L][0][1];
cout << answer;
```

---

## Динамика по профилям

Будем использовать одну формулировку задачи: "Найти количество способов замостить таблицу `n`×`m` с помощью доминошек размерами 1×2,2×1."

### Динамика по прямому профилю

Реализация за O(m × 4^n)) по времени и O(2^n) по памяти:
```cpp
// Количество всех возможных профилей = 2^n
// Профиль - битовая маска, где 1 означает горизонтальную доминошку
int size = 1 << n;

// prev - массив для предыдущего столбца (a[k-1][j])
vector<long long> prev(size, 0);
// Начальное состояние: пустой профиль (все нули)
prev[0] = 1;

// Основной цикл по столбцам (k = 1..m-1)
for (int k = 1; k < m; k++) {
    // curr - массив для текущего столбца (a[k][i])
    vector<long long> curr(size, 0);
    
    // Перебираем все профили предыдущего столбца (j)
    for (int j = 0; j < size; j++) {
        // Пропускаем недостижимые профили
        if (prev[j] == 0) continue;
        
        // Перебираем все профили текущего столбца (i)
        for (int i = 0; i < size; i++) {
            // Проверяем можно ли перейти из профиля j в профиль i
            
            // Условие 1: для горизонтальных доминошек
            // Если в i стоит 1, то в j должен стоять 0
            if ((j & i) != 0) {
                continue; // переход невозможен
            }
            
            // Условие 2: для вертикальных доминошек  
            // Оставшиеся свободные клетки должны образовывать четные группы
            int combined = j | i; // объединяем маски
            int countZeros = 0;   // счетчик подряд идущих нулей
            bool valid = true;    // флаг валидности перехода
            
            // Проходим по всем строкам
            for (int row = 0; row < n; row++) {
                if ((combined & (1 << row)) == 0) {
                    countZeros++; // свободная клетка
                } else {
                    // Проверяем предыдущую группу свободных клеток
                    if (countZeros % 2 != 0) {
                        valid = false; // нечетное количество - нельзя
                        break;
                    }
                    countZeros = 0; // сбрасываем счетчик
                }
            }
            
            // Проверяем последнюю группу свободных клеток
            if (valid && countZeros % 2 == 0) {
                // Переход возможен: a[k][i] += a[k-1][j]
                curr[i] += prev[j];
            }
        }
    }
    
        // Переходим к следующему столбцу
        prev = move(curr);
    }
    
    // Подсчет результата
    long long ans = 0;
    
    // Перебираем все возможные конечные профили
    for (int i = 0; i < size; i++) {
        // Проверяем можно ли закончить этим профилем
        // (все группы нулей должны иметь четную длину)
        int countZeros = 0;
        bool valid = true;
        
        for (int row = 0; row < n; row++) {
            if ((i & (1 << row)) == 0) {
                countZeros++; // свободная клетка
            } else {
                // Проверяем предыдущую группу
                if (countZeros % 2 != 0) {
                    valid = false;
                    break;
                }
                countZeros = 0;
            }
        }
        
        // Проверяем последнюю группу
        if (valid && countZeros % 2 == 0) {
            // Профиль допустим: ans += a[m-1][i]
            ans += prev[i];
        }
    }
    
    cout << ans << endl;
```

### Динамика по изломанному профилю

Реализация за O(n × m × 2^(m+1)) по времени и O(2^(m+1)) по памяти:
```cpp
// Для изломанного профиля используем маску длины m+1
// Профиль представляет границу между обработанной и необработанной частями
int size = 1 << (m + 1);

vector<vector<long long>> dp(2, vector<long long>(size, 0));

// Начальное состояние: вся первая строка свободна
// Профиль: все биты 0 (m+1 бит)
dp[0][0] = 1;
int curr = 0;

// Обходим таблицу СТОЛБЕЦ ЗА СТОЛБЦОМ (i) и ПОСТРОЧНО (j)
for (int i = 0; i < n; i++) { // Цикл по СТОЛБЦАМ
    for (int j = 0; j < m; j++) { // Цикл по СТРОКАМ
        int next = curr ^ 1; //трюк для хранения всего двух vector-ов в vector dp, прыгаем между ними каждый раз
        fill(dp[next].begin(), dp[next].end(), 0);
        
        for (int mask = 0; mask < size; mask++) {
            if (dp[curr][mask] == 0) continue;
            
            // Извлекаем биты для текущей и следующей позиции
            int bit_curr = (mask >> j) & 1;      // текущая клетка (j)
            int bit_next = (mask >> (j + 1)) & 1; // следующая клетка (j+1)
            
            if (bit_curr) {
                // Текущая клетка (j, i) уже занята (доминошкой 1x2 из (j, i-1) или 2x1 из (j-1, i))
                // Просто пропускаем
                int new_mask = mask & ~(1 << j); // убираем бит текущей клетки
                dp[next][new_mask] += dp[curr][mask];
            } else {
                // Текущая клетка (j, i) свободна
                
                // Вариант 1: ГОРИЗОНТАЛЬНАЯ доминошка (1×2)
                // Ставим ее на (j, i) и (j, i+1)
                if (i < n - 1) {
                    int new_mask = mask | (1 << j); // ставим бит текущей клетки (j)
                    dp[next][new_mask] += dp[curr][mask];
                }
                
                // Вариант 2: ВЕРТИКАЛЬНАЯ доминошка (2×1)
                // Ставим ее на (j, i) и (j+1, i)
                if (j < m - 1 && !bit_next) {
                    int new_mask = mask | (1 << (j + 1)); // ставим бит следующей клетки (j+1)
                    dp[next][new_mask] += dp[curr][mask];
                }
            }
        }
        
        curr = next;
    }
    
    // Переход на НОВЫЙ СТОЛБЕЦ: сдвигаем маску
    int next = curr ^ 1;
    fill(dp[next].begin(), dp[next].end(), 0);
    
    for (int mask = 0; mask < size; mask++) {
        // Самый старший бит должен быть 0 (выход за границы)
        if ((mask >> m) & 1) continue;
        
        // Сдвигаем маску влево для новой строки
        int new_mask = mask << 1;
        dp[next][new_mask] += dp[curr][mask];
    }
    
    curr = next;
}

// Ответ - количество способов с пустым профилем в конце
cout << dp[curr][0] << endl;
```

