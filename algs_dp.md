## Рюкзаки:

### Обычный рюкзак
Реализация за O(n*W)

Задача: дано ограничение по весу _W_, потом даны _n_ предметов, их веса в массиве _w_, а деньги за них в массиве _v_, надо найти макс кол-во денег.

Реализуем двумерно (O(n*W) по памяти) с восстановлением ответа:

```cpp
vector dp(n + 1, vector<int>(W + 1, 0));
for (int i = 1; i <= n; ++i) {
    for (int cap = 0; cap <= W; ++cap) {
        // Не берем i-й предмет
        dp[i][cap] = dp[i - 1][cap];
        // Берем i-й предмет (если помещается)
        if (cap >= w[i - 1]) {
            dp[i][cap] = max(dp[i][cap], dp[i - 1][cap - w[i - 1]] + v[i - 1]);
        }
    }
}
// Восстановление набора предметов
vector<int> picked;
int cap = W;
for (int i = n; i >= 1; --i) {
    // Проверяем, мог ли i-й предмет быть взят 
    if (cap >= w[i - 1] && dp[i][cap] == dp[i - 1][cap - w[i - 1]] + v[i - 1]) {
        picked.push_back(i);   // сохраняем 1-индексацию
        cap -= w[i - 1];       // уменьшаем оставшуюся вместимость
    }
    // иначе i-й не брали, просто идем дальше
}
reverse(picked.begin(), picked.end());
cout << dp[n][W] << "\n";
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```

Ниже реализация, оптимизированная до O(w) по памяти с восстановлением ответа:

```cpp
vector<int> dp(W + 1, 0);
vector<int> parent(W + 1, -1); // какой предмет последним положил оптимум в dp[cap]
for (int i = 0; i < n; ++i) {
    for (int cap = W; cap >= w[i]; --cap) {  // идём назад! — чтобы предмет i использовался 1 раз
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;
            parent[cap] = i;
        }
    }
}
cout << dp[W] << "\n";
// восстановление ответа
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];
    picked.push_back(p + 1); // переводим в 1-индексацию
    cap -= w[p];             // возвращаемся на предыдущий вес
}
for (int i = 0; i < (int)picked.size(); ++i)
    cout << picked[i] << ' ';
```
---
### Ограниченный рюкзак 
Любой предмет может быть взят некоторое количество раз (дано в условии)

Задача: дано n предметов с весами _w_i_, ценностями _v_i_ и ограничениями по количеству _c_i_, при вместимости рюкзака _W_ требуется максимизировать суммарную ценность, выбирая не более _c_i_ экземпляров каждого предмета так, чтобы суммарный вес не превышал _W_.

Сначала реализуем наивно за O(n*W\*W), но с оптимизацией по памяти, используя только два слоя
```cpp
vector<int> dp(W + 1, 0);
for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // состояние до использования предмета i
    for (int cap = 0; cap <= W; ++cap) {
        int best = prev[cap]; // k = 0 (не берем предмет i)
        for (int k = 1; k <= min(c[i], cap / w[i]); ++k) { //ограничение либо по кол-ву предмета, либо по уже набранному весу
            best = max(best, prev[cap - k * w[i]] + k * v[i]);
        }
        dp[cap] = best;
    }
}
cout << dp[W] << "\n";
```

Можно оптимизировать до O(n*w\*logw). Количество каждого предмета разложим по степеням двойки (степени двойки будем записывать СТРОГО последовательно, не как в двоичной записи числа, из-за чего в конце может быть остаток, но это не проблема) и добавим новые предметы количеством 1, и весом, равным весу предмета, умноженного на полученную в разложении степень двойки (или остаток). Затем решим как задачку обычного рюкзака.

Если требуется максимизация веса, а не стоимости, можно оптимизировать до O(n*W), используя монотонную очередь
(то есть решение неверно для приведенной выше задачи, но если надо было бы найти макс вес, то все бы работало).
```cpp
vector<int> dp(W + 1, 0);
for (int i = 0; i < n; ++i) {
    vector<int> prev = dp;
    for (int r = 0; r < w[i]; ++r) {
        // Обрабатываем все cap одной арифм. прогрессии: cap = r + m*w[i], m = 0..M.
        deque<pair<int,int>> dq; // (m', value = prev[r + m'*w] - m'*v), максимум — спереди
        int M = (W - r) / w[i];
        for (int m = 0; m <= M; ++m) {
            int idx = r + m * w[i];
            int val = prev[idx] - m * v[i];
            // Вставляем текущий m' = m, поддерживая убывание по value
            while (!dq.empty() && dq.back().second <= val) dq.pop_back();
            dq.emplace_back(m, val); //можно юзать dq.push_back({m,val})
            // Удаляем устаревшие m' < m - c[i], чтобы k = m - m' <= c[i]
            while (!dq.empty() && dq.front().first < m - c[i]) dq.pop_front();
            // Максимум в окне
            dp[idx] = dq.front().second + m * v[i];
        }
    }
}
cout << dp[W] << "\n";
```
---
###  Неограниченный рюкзак
Любой предмет может быть выбран любое количество раз

От обычного рюкзака отличается только тем, что во внутреннем цикле мы бежим не от обратного, чтобы каждый элемент можно было использовать сколь угодно раз
```cpp
vector<int> dp(W + 1, 0);
vector<int> parent(W + 1, -1); // какой предмет последним положил оптимум в dp[cap]
for (int i = 0; i < n; ++i) {
    for (int cap = w[i]; cap <= W; ++cap) {
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;
            parent[cap] = i;
        }
    }
}
cout << dp[W] << "\n";
// Восстановление
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];
    picked.push_back(p + 1); // переводим в 1-индексацию
    cap -= w[p];
}
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```
---
### (ДОП) Реализация очереди с поддержкой максимума (минимума)

**Идея реализации**

1. **Два стека**  
   - `inStack` — обычный стек для добавления элементов (`push`).  
   - `outStack` — стек пар `(значение, локальный max, локальный min)` для удаления элементов (`pop`) с хранением локального максимума и минимума.  

2. **Добавление элемента (`push`)**  
   - Кладём значение в `inStack`.  
   - Локальный max/min не нужен на этом этапе, поэтому пары не создаём.  

3. **Удаление элемента (`pop`)**  
   - Если `outStack` пуст, переносим все элементы из `inStack` в `outStack`.  
   - При переносе для каждого элемента пересчитываем локальный max/min относительно уже заполненного `outStack`:  
     ```
     локальный max = max(значение, верхний локальный max outStack)
     локальный min = min(значение, верхний локальный min outStack)
     ```
   - После этого удаляем верхний элемент `outStack`.  

4. **Получение фронт-элемента (`front`)**  
   - Если `outStack` пуст, сначала делаем перенос.  
   - Верх `outStack` — это первый элемент очереди.  

5. **Получение максимума/минимума всей очереди (`getMax` / `getMin`)**  
   - Берём максимум и минимум из двух источников:  
     - `outStack.top().curMax` и `outStack.top().curMin` (элементы готовые к удалению).  
     - `inStack` — если нужно, можно пройти по нему, чтобы найти max/min среди ещё не перенесённых элементов.  
   - Амортизированно операции остаются **O(1)**, так как пересчёт по `inStack` выполняется только при переносе.  
