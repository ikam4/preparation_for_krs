План: 
1) ~Дописать про последовательности (НОП и НОВП)~
2) ДП на подмножествах
3) Комбинаторика: разряды числа
4) Динамика по профилям (обычному и изломанному)
5) Принцип включений-исключений
6) Число путей в табличке n x m из (1, 1) в (n, m) при наличии стенок
7) Оптимизировать коммивояжера 

## Рюкзаки:

### Обычный рюкзак
Реализация за O(n*W)

Задача: дано ограничение по весу `W`, потом даны `n` предметов, их веса в массиве `w`, а деньги за них в массиве `v`, надо найти макс кол-во денег.

Реализуем двумерно (O(n*W) по памяти) с восстановлением ответа:

```cpp
vector dp(n + 1, vector<int>(W + 1, 0));
for (int i = 1; i <= n; ++i) {
    for (int cap = 0; cap <= W; ++cap) {
        // Не берем i-й предмет
        dp[i][cap] = dp[i - 1][cap];
        // Берем i-й предмет (если помещается)
        if (cap >= w[i - 1]) {
            dp[i][cap] = max(dp[i][cap], dp[i - 1][cap - w[i - 1]] + v[i - 1]);
        }
    }
}
// Восстановление набора предметов
vector<int> picked;
int cap = W;
for (int i = n; i >= 1; --i) {
    // Проверяем, мог ли i-й предмет быть взят 
    if (cap >= w[i - 1] && dp[i][cap] == dp[i - 1][cap - w[i - 1]] + v[i - 1]) {
        picked.push_back(i);   // сохраняем 1-индексацию
        cap -= w[i - 1];       // уменьшаем оставшуюся вместимость
    }
    // иначе i-й не брали, просто идем дальше
}
reverse(picked.begin(), picked.end());
cout << dp[n][W] << "\n";
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```

Ниже реализация, оптимизированная до O(w) по памяти с восстановлением ответа:

```cpp
vector<int> dp(W + 1, 0);
vector<int> parent(W + 1, -1); // какой предмет последним положил оптимум в dp[cap]
for (int i = 0; i < n; ++i) {
    for (int cap = W; cap >= w[i]; --cap) {  // идём назад! — чтобы предмет i использовался 1 раз
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;
            parent[cap] = i;
        }
    }
}
cout << dp[W] << "\n";
// восстановление ответа
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];
    picked.push_back(p + 1); // переводим в 1-индексацию
    cap -= w[p];             // возвращаемся на предыдущий вес
}
for (int i = 0; i < (int)picked.size(); ++i)
    cout << picked[i] << ' ';
```
---
### Ограниченный рюкзак 
Любой предмет может быть взят некоторое количество раз (дано в условии)

Задача: дано n предметов с весами `w_i`, ценностями `v_i` и ограничениями по количеству `c_i`, при вместимости рюкзака `W` требуется максимизировать суммарную ценность, выбирая не более `c_i` экземпляров каждого предмета так, чтобы суммарный вес не превышал `W`.

Сначала реализуем наивно за O(n*W\*W), но с оптимизацией по памяти, используя только два слоя
```cpp
vector<int> dp(W + 1, 0); // dp[cap] — максимальная ценность для вместимости cap

// Обрабатываем каждый предмет
for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // сохраняем состояние dp до использования предмета i

    // Пробегаем по всем возможным вместимостям
    for (int cap = 0; cap <= W; ++cap) {
        int best = prev[cap]; // k = 0, не берем предмет i

        // Пробуем взять k штук предмета i, где k не превышает ограничения c[i]
        // и вместимость cap позволяет взять k штук
        for (int k = 1; k <= min(c[i], cap / w[i]); ++k) {
            best = max(best, prev[cap - k * w[i]] + k * v[i]); // выбираем максимум
        }

        dp[cap] = best; // обновляем dp для текущей вместимости
    }
}

// Выводим максимальную ценность для вместимости W
cout << dp[W] << "\n";
```

Можно оптимизировать до O(n*w\*logw). Количество каждого предмета разложим по степеням двойки (степени двойки будем записывать СТРОГО последовательно, не как в двоичной записи числа, из-за чего в конце может быть остаток, но это не проблема) и добавим новые предметы количеством 1, и весом, равным весу предмета, умноженного на полученную в разложении степень двойки (или остаток). Затем решим как задачку обычного рюкзака.

Если требуется максимизация веса, а не стоимости, можно оптимизировать до O(n*W), используя монотонную очередь
(то есть решение неверно для приведенной выше задачи, но если надо было бы найти макс вес, то все бы работало).
```cpp
vector<int> dp(W + 1, 0); // dp[r] — максимальный вес для вместимости r (если максимизируем вес)

for (int i = 0; i < n; ++i) {
    vector<int> prev = dp; // сохраняем состояние до обработки предмета i

    // Разбиваем все вместимости по остаткам от деления на w[i]
    // Это позволяет обрабатывать все cap вида r + m*w[i], m = 0..M
    for (int r = 0; r < w[i]; ++r) {
        deque<pair<int,int>> dq; // хранит пары (m', value), максимум в окне спереди
        int M = (W - r) / w[i];  // максимальное количество предметов данного типа для остатка r

        for (int m = 0; m <= M; ++m) {
            int idx = r + m * w[i];       // текущая вместимость
            int val = prev[idx] - m * v[i]; // значение для текущего количества m (если максимизируем вес, v[i] = w[i])

            // Поддерживаем убывающий порядок value в деке
            while (!dq.empty() && dq.back().second <= val) dq.pop_back();
            dq.emplace_back(m, val); // вставляем текущий m

            // Удаляем устаревшие элементы из передней части дека
            // чтобы не превышать ограничение по количеству c[i]
            while (!dq.empty() && dq.front().first < m - c[i]) dq.pop_front();

            // Максимум в текущем окне — спереди
            dp[idx] = dq.front().second + m * v[i]; // обновляем dp
        }
    }
}

cout << dp[W] << "\n"; // максимальный вес для вместимости W
```
---
###  Неограниченный рюкзак
Любой предмет может быть выбран любое количество раз

От обычного рюкзака отличается только тем, что во внутреннем цикле мы бежим не от обратного, чтобы каждый элемент можно было использовать сколь угодно раз
```cpp
vector<int> dp(W + 1, 0);       // dp[cap] — максимальная ценность для вместимости cap
vector<int> parent(W + 1, -1);  // parent[cap] — какой предмет последним положил оптимум

// Основной DP для неограниченного рюкзака
for (int i = 0; i < n; ++i) {
    for (int cap = w[i]; cap <= W; ++cap) {
        // Рассматриваем возможность добавить текущий предмет i
        int cand = dp[cap - w[i]] + v[i];
        if (cand > dp[cap]) {
            dp[cap] = cand;       // обновляем максимум
            parent[cap] = i;      // сохраняем индекс предмета, который дал этот максимум
        }
    }
}

// Вывод максимальной ценности
cout << dp[W] << "\n";

// Восстановление выбранных предметов
vector<int> picked;
int cap = W;
while (cap > 0 && parent[cap] != -1) {
    int p = parent[cap];           // предмет, который последним положили
    picked.push_back(p + 1);       // переводим в 1-индексацию для удобного вывода
    cap -= w[p];                   // уменьшаем вместимость на вес выбранного предмета
}

// Вывод выбранных предметов
for (int i = 0; i < (int)picked.size(); ++i) 
    cout << picked[i] << ' ';
```
---
### (ДОП) Реализация очереди с поддержкой максимума (минимума)

**Идея реализации**

1. **Два стека**  
   - `inStack` — обычный стек для добавления элементов (`push`).  
   - `outStack` — стек пар `(значение, локальный max, локальный min)` для удаления элементов (`pop`) с хранением локального максимума и минимума.  

2. **Добавление элемента (`push`)**  
   - Кладём значение в `inStack`.  
   - Локальный max/min не нужен на этом этапе, поэтому пары не создаём.  

3. **Удаление элемента (`pop`)**  
   - Если `outStack` пуст, переносим все элементы из `inStack` в `outStack`.  
   - При переносе для каждого элемента пересчитываем локальный max/min относительно уже заполненного `outStack`:  
     ```
     локальный max = max(значение, верхний локальный max outStack)
     локальный min = min(значение, верхний локальный min outStack)
     ```
   - После этого удаляем верхний элемент `outStack`.  

4. **Получение фронт-элемента (`front`)**  
   - Если `outStack` пуст, сначала делаем перенос.  
   - Верх `outStack` — это первый элемент очереди.  

5. **Получение максимума/минимума всей очереди (`getMax` / `getMin`)**  
   - Берём максимум и минимум из двух источников:  
     - `outStack.top().curMax` и `outStack.top().curMin` (элементы готовые к удалению).  
     - `inStack` — если нужно, можно пройти по нему, чтобы найти max/min среди ещё не перенесённых элементов.  
   - Амортизированно операции остаются **O(1)**, так как пересчёт по `inStack` выполняется только при переносе.

**Объяснение от Максима Г.:**

Будем хранить два стека - In(std::stack<T>), Out(std::stack<pair<T, T>>) и переменную M в которой будем хранить max/min в In.
Добавлять элементы будем In, тогда M = max/min(M, value). Когда необходимо будет удалить элемент, возможны два варианта: 
1) Out.size() == 0: тогда переносим все элементы из In в Out начиная с конца следующим образом: .first = value, .second = max/min на префиксе. Тогда первый элемент из In будет последним в Out и его смело можно удалять и max/min нашей структуры будет равен Out.top().second.
2) Out.size() != 0: тогда мы удаляем последний элемент из Out(то есть самый первый в нашей "очереди"), но ответ будет уже равен max/min(Out.top().second, M)

---
---
## Последовательности:

### НВП (наибольшая возрастающая подпоследовательность)

Задача: в массиве `arr` записаны числа, найти их НВП.

Реализуем решение наивно за O(n*n):
```cpp
int n = arr.size();
vector<int> dp(n, 1);       // dp[i] — длина НВП, оканчивающейся в i
vector<int> prev(n, -1);    // prev[i] — предыдущий индекс в НВП для восстановления

// Основной DP: для каждого элемента i проверяем элементы j < i
// и продолжаем возрастающую подпоследовательность
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
            dp[i] = dp[j] + 1; // увеличиваем длину НВП
            prev[i] = j;       // сохраняем предыдущий элемент
        }
    }
}

// Находим индекс конца НВП
auto it = max_element(dp.begin(), dp.end());
int lis_len = *it;           // длина НВП
int index = it - dp.begin(); // индекс конца НВП

// Восстанавливаем НВП
vector<int> lis;
while (index != -1) {
    lis.push_back(arr[index]); // добавляем элемент
    index = prev[index];       // идём к предыдущему элементу
}
reverse(lis.begin(), lis.end()); // переворачиваем для правильного порядка

// Вывод результатов
cout << lis.size() << '\n'; // длина НВП
for (auto i : lis)           // сами элементы НВП
    cout << i << ' ';
```

Оптимизируем решение до O(n*logn), немного изменив логику dp:

```cpp
int n = a.size();

vector<int> dp(n + 1, INT_MAX);       // dp[i] — минимальный конец возрастающей подпоследовательности длины i
vector<int> pos(n + 1, -1);  // pos[i] — индекс элемента, который завершает подпоследовательность длины i
vector<int> prev(n, -1);     // prev[i] — предыдущий индекс элемента для восстановления НВП
dp[0] = INT_MIN;             // для длины 0
int length = 0;

for (int i = 0; i < n; i++) {
    // бинарный поиск: найти j, чтобы dp[j-1] < a[i] <= dp[j]
    int j = lower_bound(dp.begin(), dp.begin() + n + 1, a[i]) - dp.begin();
    if (a[i] != dp[j]) { //чтобы не восстановилось два одинаковых элемента
        dp[j] = a[i];
        pos[j] = i;               // запоминаем индекс элемента
        prev[i] = pos[j - 1];     // предыдущий элемент НВП
        length = max(length, j);  // обновляем длину НВП
    }
}

// Восстановление НВП
vector<int> lis;
int p = pos[length];
while (p != -1) {
    lis.push_back(a[p]);
    p = prev[p];
}
reverse(lis.begin(), lis.end());

// Вывод результатов
cout << lis.size() << '\n';
for (int x : lis)
    cout << x << ' ';
```
---
### НОП (наибольшая общая подпоследовательность)

Задача: в массивах `a` и `b` записаны числа, найти их НОП.

Реализуем решение за O(n*w):
```cpp
    int n = a.size();
    int m = b.size();

    // dp[i][j] — длина НОП для a[0..i-1] и b[0..j-1]
    vector dp(n + 1, vector<int>(m + 1, 0));

    // Заполняем DP
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i - 1] == b[j - 1])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    // Восстановление
    int i = n, j = m;
    vector<int> res;

    while (i > 0 && j > 0) {
        if (a[i - 1] == b[j - 1]) {
            res.push_back(a[i - 1]);
            i--;
            j--;
        } else {
            if (dp[i - 1][j] >= dp[i][j - 1])
                i--;
            else
                j--;
        }
    }

    reverse(res.begin(), res.end());
```
---
### НОВП (наибольшая общая возрастающая последовательность)

Задача: в массивах `a` и `b` записаны числа, найти их НОВП.

Наивное решение за O(n\*n\*m\*m): dp[i][j] - максимальная длина НОВП, заканчивающейся в позициях i и j, переход за O(n*m) через прямой перебор предыдущих значений i и j

Более оптимизированное O(n\*m\*m): dp[i][j] - максимальная длина НОВП, заканчивающейся в позиции j второй строки, переход либо к dp[i - 1][j], либо к 1 + dp[i - 1][j'] за O(m) через прямой перебор j'

Оптимизируем до O(n*m), используя доп. переменную best:
dp как в прошлом решении. Основная сложность прошлого решения - поиск j' = arg max(dp[i - 1][j']) при b[j'] < b[j] и j' < j. Значение j' вычисляется только при b[j] = a[i]. Считаем динамику первым циклом по возрастанию i, значит a[i] фиксировано, а значит и b[j] фиксировано. И значение j' можно поддерживать на префиксе за O(1) при переходе от j к j + 1

Реализация за O(n*m):
```cpp
// dp[i][j]  — длина НОВП для префиксов a[0..i-1], b[0..j-1],
//               заканчивающаяся на элементе b[j-1], если a[i-1] == b[j-1].
// prev[j]   — позиция предыдущего элемента НОВП в массиве b (для восстановления).

vector dp(n + 1, vector<int>(m + 1, 0));
vector<int> prev(m + 1, 0);

for (int i = 1; i <= n; ++i) {
    int best = 0;     // лучшая длина НОВП среди b[0..j-1], но только тех b[k] < a[i-1]
    int idx = 0;      // позиция b[k], которая даёт best
    for (int j = 1; j <= m; ++j) {
        // По умолчанию: НОВП не улучшается по сравнению с dp[i-1][j]
        dp[i][j] = dp[i - 1][j];
        // Если найден общий элемент, и можно улучшить НОВП, заканчивающуюся на b[j-1]
        if (a[i - 1] == b[j - 1] && dp[i - 1][j] < best + 1) {
            dp[i][j] = best + 1;
            prev[j] = idx;   // сохраним, откуда мы пришли
        }
        // Если b[j-1] < a[i-1], то этот b[j-1] можно использовать
        // как возможный предыдущий элемент НОВП.
        // И если dp[i-1][j] лучше нынешнего "best" → обновляем best.
        if (a[i - 1] > b[j - 1] && best < dp[i - 1][j]) {
            best = dp[i - 1][j];
            idx = j;
        }
    }
}

// Теперь находим, где НОВП заканчивается
int pos = 0;
for (int j = 1; j <= m; ++j) {
    if (dp[n][j] > dp[n][pos]) {
        pos = j;
    }
}

// Восстановление ответа
vector<int> ans;
while (pos != 0) {
    ans.push_back(b[pos - 1]);  // берем элемент
    pos = prev[pos];            // двигаемся по цепочке
}

// Ответ восстановлен в обратном порядке
reverse(ans.begin(), ans.end());
// Вывод
cout << ans.size() << "\n";
for (int x : ans) cout << x << " ";
```
---
---
## ДП на подмножествах

### Задача о сумме подмножеств элементов

Условие: сколько подмножеств элементов в множестве `a` размером `n` имеют сумму не меньше X.

Решение за O(2^n):
```cpp
int total_masks = 1 << n;              // всего подмножеств
vector<long long> dp(total_masks);     // dp[mask] = сумма элементов в подмножестве mask

dp[0] = 0;                             // пустое подмножество

for (int mask = 1; mask < total_masks; ++mask) {
    // lsb — младший установленный бит в mask
    int lsb = mask & -mask;           // бит, соответствующий одному элементу
    // индекс этого бита: количество нулей в конце
    int i = __builtin_ctz(lsb);       // позиция элемента, который добавили
    int prev = mask ^ lsb;           // маска без этого элемента
    dp[mask] = dp[prev] + a[i];      // сумма = сумма без элемента + значение элемента
}

long long answer = 0;
for (int mask = 0; mask < total_masks; ++mask) {
    if (dp[mask] >= X) {
        ++answer;
    }
}

// если НЕ хотим считать пустое подмножество
// if (dp[0] >= X) --answer;

cout << answer << "\n";
```
Примечание: 
- -mask = 1 + ~mask (так хранятся в памяти компьютера отрицательные числа)
- mask:     ...xxxxx1000  (x - любые биты)
- ~mask:    ...yyyyy0111  (y - инвертированные x)
- -mask:    ...yyyyy1000  (+1 вызывает перенос до первой единицы)

Поэтому mask & -mask возвращает первый справа единичный бит.

Можно брать и первый слева единичный бит следующим образом (если берем у int, который 32 бита): `int i = 31 - __builtin_ctz(lsb); `

---
### Задача коммивояжера

- `n` городов и матрица расстояний `dist[i][j]` между ними.
- Требуется найти **замкнутый маршрут минимальной длины**, который:
  - Начинается и заканчивается в одном и том же городе.
  - Посещает каждый город **ровно один раз**.

#### Основные понятия

1. Маска посещенных городов представляется как целое число, где каждый бит соответствует городу: `1` — город посещён, `0` — город ещё не посещён.
2. `dp[mask][v]` — минимальная стоимость пути, который проходит через все города из `mask` и заканчивается в городе `v`.
3. В `parent[mask][v]` сохраняем предыдущий город для восстановления полного маршрута.


#### Шаги алгоритма

1. Инициализация
    - Выбираем стартовый город (например, город 0).
    - `dp[1 << 0][0] = 0` — путь, который включает только стартовый город, имеет длину 0.
    - Если между двумя городами пути нет, в матрице расстояний ставим `INF` (большое число).

2. Заполнение DP (для каждой `mask` и города `u` в маске):
    - Проверяем все города `v`, которых ещё нет в маске (`mask & (1 << v) == 0`).
    - Вычисляем новую маску: `nmask = mask | (1 << v)`.
    - Если путь через `u` к `v` улучшает текущую стоимость:
       - Обновляем `dp[nmask][v] = dp[mask][u] + dist[u][v]`.
       - Запоминаем родителя: `parent[nmask][v] = u`.
    - Таким образом, постепенно строим минимальные пути для всех возможных подмножеств городов.

3. После того как посещены все города (`mask = FULL-1`):
    - Рассматриваем все возможные последние города `u`.
    - Добавляем стоимость возврата в стартовый город: `dp[FULL-1][u] + dist[u][0]`.
    - Выбираем минимальное значение — это **минимальная длина замкнутого маршрута**.

4. Восстановление маршрута
    - Начинаем с последнего города `last`, который дал минимальную стоимость.
    - Используем массив `parent` и маску `mask`, чтобы идти **назад** по маршруту, пока не достигнем стартового города.
    - Разворачиваем полученный путь и добавляем стартовый город в конец, чтобы получить полный цикл.

#### Сложность алгоритма
- Время: `O(n^2 * 2^n)`  
- Память: `O(n * 2^n)`  

#### Пример реализации: 
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long INF = 1e18;

int main() {
    int n;
    cin >> n; // количество городов
    vector dist(n, vector<long long>(n));
    
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < n; ++j){
            cin >> dist[i][j];
            if(dist[i][j] < 0) dist[i][j] = INF; // если пути нет
        }

    int FULL = 1 << n; // все возможные подмножества городов
    vector dp(FULL, vector<long long>(n, INF));
    vector parent(FULL, vector<int>(n, -1));

    dp[1][0] = 0; // стартуем с города 0

    // перебираем все подмножества городов
    for(int mask = 1; mask < FULL; ++mask) {
        for(int u = 0; u < n; ++u) {
            if(!(mask & (1 << u))) continue; // город u не в маске
            if(dp[mask][u] == INF) continue;

            // пробуем добавить следующий город v
            for(int v = 0; v < n; ++v) {
                if(mask & (1 << v)) continue; // город уже в пути
                if(dist[u][v] == INF) continue; // пути нет
                int nmask = mask | (1 << v);
                if(dp[mask][u] + dist[u][v] < dp[nmask][v]) {
                    dp[nmask][v] = dp[mask][u] + dist[u][v];
                    parent[nmask][v] = u;
                }
            }
        }
    }

    // закрываем цикл, возвращаемся в старт
    long long best = INF;
    int last = -1;
    for(int u = 0; u < n; ++u) {
        if(dp[FULL-1][u] == INF || dist[u][0] == INF) continue;
        long long cost = dp[FULL-1][u] + dist[u][0];
        if(cost < best) {
            best = cost;
            last = u;
        }
    }

    if(best == INF) {
        cout << "NO SOLUTION\n";
        return 0;
    }

    // восстановление пути
    vector<int> path;
    int mask = FULL-1, v = last;
    while(v != -1) {
        path.push_back(v);
        int pv = parent[mask][v];
        mask ^= (1 << v);
        v = pv;
    }
    reverse(path.begin(), path.end());
    path.push_back(0); // возвращение в старт

    // вывод
    cout << best << "\n";
    for(int i = 0; i < path.size(); ++i) {
        cout << (path[i] + 1) << ' '; // 1-based номера городов
    }
}
```
